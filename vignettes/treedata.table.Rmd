---
title: "Getting Started With The treedata.table Package"
author: "the vignette on the orient express"
date: "11/8/2019"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting Started With The treedata.table Package}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Getting Started With The `treedata.table` Package

The aim of the treedata.table R package is to allow researchers to access and manipulate phylogenetic data using tools from the `data.table` package. `data.table` has many functions for rapidly manipulating data in a memory efficient way. 

Using the `treedata.table` package begins with creating a `treedata.table` object. The `treedata.table` matches the tip.labels of the phylogeny to a column of names in your `data.frame`. This allows you to manipulate the data, and the corresponding tree together.

A `treedata.table` is created using the `as.treedata.table` function. 

```{r}
library(ape)
library(treedata.table)

# Load example data
data(anolis)
#Create treedata.table object with as.treedata.table
td <- as.treedata.table(tree = anolis$phy, data = anolis$dat)
```

We may inspect our object by calling it by name. You will notice that your `data.frame` is now a `data.table`.

```{r}
td
```


Furthermore, the new `data.table` has been reordered into the same order as the tip.labels of your tree.

```{r}
td$phy$tip.label == td$dat$tip.label
```


## Manipulating Data

Your data table can be indexed in the same way any other `data.table` object would be. For example, if we wanted to look at our snout-vent length column, we can do that like so.

```{r pressure, echo=TRUE}
td$dat[,SVL]

```

You can also use double bracket syntax to directly return column data as a named list.

```{r}
td[["SVL"]]
```

The same functionality can also be accomplished through the `extractVector` function. Both the double bracked syntax and the `extractVector` function will return a named vector.

```{r}
extractVector(td, SVL)
```


The real power in treedata.table is in co-indexing the tree and table. For example, in the below command, we use `data.table` syntax to take the first representative from each ecomorph. We retain all data columns. If you examine the tree object, you will see that it has had all the tips not in the resultant `data.table` dropped.

```{r}
 td[, head(.SD, 1), by = "ecomorph"]

```

We could also do the same operation with multiple columns:

```{r}
td[, head(.SD, 1), by = .(ecomorph, island)]

```

Columns in the `data.table` can also be operated on using `data.table` syntax. In the below example, the tree is pruned to those tips that occur in Cuba. This is the `data.table` equivalent of `dplyr`'s filter. Then, a new column is created in the `data.table`, assigned the name "Index", and assigned the value of the SVL + the hostility index. This enables concurrent manipulation of the phylogeny, and the calculation of a new index for only those tips we would actually like to use.

```{r}
td[island == "Cuba",.(Index=SVL+hostility)]
```

We can extend this tidy approach to actually estimating values for our data using `tdt`. In the below command, we extract two vectors from our data.table and use `geiger`'s continuous model fitting to estimate a Brownian motion model for the data. 


```{r}

tdt(td, geiger::fitContinuous(phy, extractVector(td, SVL), model="BM", ncores=1))

```


We can also drop tips directly from the tree, and have those tips drop concurrently from the data.table. In the example below, we  remove two taxa by name. Please note that the below is intended as an interactive function.

```{r, eval=FALSE}
to_drop <- c("chamaeleonides" ,"eugenegrahami" )

dt <- droptreedata.table(tdObject=td, taxa=to_drop)

to_drop %in% dt$phy$tip.label

[1] FALSE FALSE

to_drop %in% dt$dat$X

[1] FALSE FALSE


```




When you're done, the data.table and tree can both be extracted from the object:

```{r}

df <- pull.treedata.table(td, "dat")
tree <- pull.treedata.table(td, "tree")
```

The table

```{r}
df
```

and the respective tree

```{r}
tree
```



# Advanced methods

## Working with multiphylo objects

`treedata.table` further allows the matching of multiple phylogenies (`multiPhylo`) against a single dataset (`data.frame`). Below, we modified the anole dataset to explain the extended functionality of `treedata.table` with `multiPhylo` objects.


We first create a `multiPhylo` object including only two `phylo` objects. Users can provide any number of `phylo` objects within the `multiPhylo` object. However, trees should only differ in their topology. In other words, all trees must have the same tip labels. Nevertheless, both the provided `multiPhylo` and `data.frame` should partially overlap.

```{r}
trees<-list(anolis$phy,anolis$phy)
class(trees) <- "multiPhylo"
trees
```

Now, we create our treedata.table object by combining the trait data (`data.frame`) and the newly generated `multiPhylo` object.

```{r}
td <- as.treedata.table(tree=trees, data=anolis$dat)
```

The resulting `td` object now returns a `multiPhylo` object under `phy` 

```{r}
class(td$phy);td$phy
```

Please note that all the basic `treedata.table` fucntions highlighted above for `phylo` objects are still functional when `treedata.table` objects include `multiPhylo` objects.

```{r}
td[, head(.SD, 1), by = "ecomorph"]
```

Functions can also be run on any `treedata.table` object with `multiphylo` data. For instance, the following line will fit a phenogram for `SVL` on each of the trees we provided in the `multiPhylo` object.

```{r}
tdt(td, geiger::fitContinuous(phy, extractVector(td, SVL), model="BM", ncores=1))
```

The output is an object of class `list` with each element corresponding to the output function of each tree in the provided `multiPhylo` object. 


## Partially matching trait data and tree(s)

The `as.treedata.table` function enables users to match a tree (or multiple trees) against a single trait database.

Tips that are not common between the tree (or trees) and dataset are dropped from the resulting `treedata.table` object. For instance, below I have modified the original anole phylogeny such that *A. ahli* (**ahi**) is replaced for a label that is not present in the dataset (**NAA**).

```{r}
anolis_newtip<-anolis$phy
anolis_newtip$tip.label[1]<-'NAA'
anolis_newtip
```


We then use this modified tree to fit a `treedata.table` object using the `as.treedata.table` function:


```{r}
td <- as.treedata.table(tree=anolis_newtip, data=anolis$dat)
```

Note that `as.treedata.table` drops all non-overlaping tips (**NAA** [present in the tree but not in the trait data] and **ahi** [present in the database but not in tree] in this case) and returns a `treedata.table` object with fully matching `phy` and `data` objects. 

```{r}
td
```


Fully-matching matrix and trees are also returned in `treedata.table` objects with `multiPhylo` objects in their `phy` component. See the example below.

We first construct a `multiPhylo` object that partially overlaps the original trait database by using **NAA** instead of **ahi**.

```{r}
anolis2<-anolis$phy
anolis2$tip.label[1]<-'NAA'
anolis1<-anolis$phy
anolis1$tip.label[1]<-'NAA'
trees<-list(anolis1,anolis2)
class(trees) <- "multiPhylo"
trees
```

Next, we fit the `treedata.table` object using the relevant `multiPhylo` object and the original trait database.

```{r}
td <- as.treedata.table(tree=trees, data=anolis$dat)
```

Note that 1 tip was dropped for all trees in the `multiPhylo` object and a single row was deleted from the `data.table` object in the `treedata.table` object.

```{r}
td
```









